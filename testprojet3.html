<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trap Master - Jeu de Plateforme</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Arial', sans-serif; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); display: flex; justify-content: center; align-items: center; min-height: 100vh; color: #fff; }
        .container { background: rgba(22, 33, 62, 0.95); padding: 30px; border-radius: 15px; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5); max-width: 900px; width: 100%; }
        .menu-screen { display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; }
        .menu-screen.hidden { display: none; }
        .menu-title { font-size: 3.5em; margin-bottom: 20px; color: #ff6b6b; text-shadow: 0 0 20px rgba(255, 107, 107, 0.5); animation: pulse 2s infinite; }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
        .menu-subtitle { font-size: 1.3em; color: #aaa; margin-bottom: 40px; }
        .levels-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 20px; margin-bottom: 40px; width: 100%; }
        .level-btn { padding: 30px; font-size: 1.2em; border: 3px solid #ff6b6b; background: linear-gradient(135deg, rgba(255, 107, 107, 0.2), rgba(255, 107, 107, 0.05)); color: #ff6b6b; border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.3s ease; text-transform: uppercase; }
        .level-btn:hover { background: linear-gradient(135deg, rgba(255, 107, 107, 0.4), rgba(255, 107, 107, 0.2)); transform: translateY(-5px); box-shadow: 0 10px 25px rgba(255, 107, 107, 0.3); }
        .level-btn:active { transform: translateY(0); }
        .level-btn.locked { opacity: 0.5; cursor: not-allowed; border-color: #666; color: #666; }
        .level-btn.locked:hover { background: linear-gradient(135deg, rgba(255, 107, 107, 0.1), rgba(255, 107, 107, 0.05)); transform: none; box-shadow: none; }
        .menu-info { background: rgba(78, 205, 196, 0.1); border: 2px solid #4ecdc4; border-radius: 8px; padding: 20px; font-size: 0.95em; line-height: 1.6; width: 100%; }
        .game-screen { display: flex; flex-direction: column; }
        .game-screen.hidden { display: none; }
        .header { text-align: center; margin-bottom: 20px; }
        .header h1 { font-size: 2.5em; margin-bottom: 5px; color: #ff6b6b; text-shadow: 0 0 10px rgba(255, 107, 107, 0.5); }
        .header p { font-size: 1.1em; color: #aaa; }
        .game-wrapper { background: #000; border: 4px solid #ff6b6b; border-radius: 10px; overflow: hidden; margin-bottom: 20px; box-shadow: 0 0 20px rgba(255, 107, 107, 0.3); }
        canvas { display: block; background: linear-gradient(180deg, #87CEEB 0%, #E0F6FF 100%); width: 100%; height: auto; }
        .info-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px; }
        .info-box { background: rgba(255, 107, 107, 0.1); border: 2px solid #ff6b6b; border-radius: 8px; padding: 15px; font-size: 0.95em; }
        .info-box h3 { color: #ff6b6b; margin-bottom: 10px; font-size: 1.1em; }
        .info-box p { margin: 5px 0; color: #ddd; }
        .stat { display: flex; justify-content: space-between; align-items: center; margin: 8px 0; }
        .stat-label { color: #aaa; }
        .stat-value { color: #ff6b6b; font-weight: bold; font-size: 1.2em; }
        .controls-list { list-style: none; font-size: 0.9em; }
        .controls-list li { margin: 6px 0; padding-left: 20px; position: relative; }
        .controls-list li:before { content: "‚ñ∂"; position: absolute; left: 0; color: #ff6b6b; }
        .button-group { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 20px; }
        button { padding: 12px 20px; font-size: 1em; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; transition: all 0.3s ease; text-transform: uppercase; }
        .btn-reset { background: linear-gradient(135deg, #ff6b6b, #ff5252); color: white; }
        .btn-reset:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4); }
        .btn-pause { background: linear-gradient(135deg, #4ecdc4, #44a08d); color: white; }
        .btn-pause:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(78, 205, 196, 0.4); }
        .btn-menu { background: linear-gradient(135deg, #9b59b6, #8e44ad); color: white; }
        .btn-menu:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(155, 89, 182, 0.4); }
        .objective { background: rgba(78, 205, 196, 0.1); border: 2px solid #4ecdc4; border-radius: 8px; padding: 15px; font-size: 0.95em; line-height: 1.6; }
        .objective h3 { color: #4ecdc4; margin-bottom: 10px; }
        .objective p { color: #ddd; }
        .legend { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-top: 15px; font-size: 0.9em; }
        .legend-item { display: flex; align-items: center; gap: 8px; }
        .legend-color { width: 20px; height: 20px; border-radius: 3px; }
        .color-player { background: #FF0000; }
        .color-platform { background: #8B4513; }
        .color-spike { background: #FF0000; }
        .color-falling { background: #FFD700; }
        .color-delayed { background: #FF69B4; }
        @media (max-width: 768px) { .container { padding: 15px; } .header h1 { font-size: 1.8em; } .info-grid { grid-template-columns: 1fr; } .button-group { grid-template-columns: 1fr; } .levels-grid { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <div class="container">
        <div id="menuScreen" class="menu-screen">
            <h1 class="menu-title">üéÆ TRAP MASTER</h1>
            <p class="menu-subtitle">Choisissez votre niveau</p>
            <div class="levels-grid">
                <button class="level-btn" onclick="startGame(1)">üìç Niveau 1<br><small>D√©butant</small></button>
                <button class="level-btn locked">üìç Niveau 2<br><small>Bient√¥t</small></button>
                <button class="level-btn locked">üìç Niveau 3<br><small>Bient√¥t</small></button>
            </div>
            <div class="menu-info">
                <h3>üìñ √Ä propos</h3>
                <p>Trap Master est un jeu de plateforme impitoyable o√π vous devez naviguer √† travers des pi√®ges mortels. Utilisez votre agilit√© et votre m√©moire pour survivre!</p>
                <p style="margin-top: 10px;"><strong>üí° Astuce :</strong> Vous pouvez sauter deux fois en appuyant deux fois sur la fl√®che du haut! Chaque mort g√©n√®re un <strong>nouveau niveau</strong>!</p>
            </div>
        </div>

        <div id="gameScreen" class="game-screen hidden">
            <div class="header">
                <h1>üéÆ TRAP MASTER</h1>
                <p id="levelTitle">Niveau 1 - Survivez aux Pi√®ges!</p>
            </div>
            <div class="game-wrapper">
                <canvas id="gameCanvas" width="800" height="600"></canvas>
            </div>
            <div class="info-grid">
                <div class="info-box">
                    <h3>üìä Statistiques</h3>
                    <div class="stat"><span class="stat-label">Morts:</span><span class="stat-value" id="deathCount">0</span></div>
                    <div class="stat"><span class="stat-label">Position X:</span><span class="stat-value" id="posX">0</span></div>
                    <div class="stat"><span class="stat-label">Position Y:</span><span class="stat-value" id="posY">0</span></div>
                    <div class="stat"><span class="stat-label">√âtat:</span><span class="stat-value" id="status">En jeu</span></div>
                </div>
                <div class="info-box">
                    <h3>‚å®Ô∏è Contr√¥les</h3>
                    <ul class="controls-list">
                        <li>Fl√®ches / WASD - Se d√©placer</li>
                        <li>Espace / Haut (x2) - Sauter / Double Saut</li>
                        <li>P - Pause/Reprendre</li>
                        <li>R - Nouveau Niveau (Reset)</li>
                    </ul>
                </div>
            </div>
            <div class="button-group">
                <button class="btn-pause" id="pauseBtn">‚è∏Ô∏è Pause</button>
                <button class="btn-reset" id="resetBtn">üîÑ Nouveau Niveau</button>
                <button class="btn-menu" id="menuBtn">üè† Menu</button>
            </div>
            <div class="objective">
                <h3>üéØ Objectif</h3>
                <p>Naviguez √† travers les plateformes et √©vitez tous les pi√®ges pour atteindre le drapeau vert (FIN). Attention : Le niveau change √† chaque mort !</p>
                <div class="legend">
                    <div class="legend-item"><div class="legend-color color-player"></div><span>Joueur</span></div>
                    <div class="legend-item"><div class="legend-color color-platform"></div><span>Plateforme</span></div>
                    <div class="legend-item"><div class="legend-color color-spike"></div><span>Pi√®ge √† pointe</span></div>
                    <div class="legend-item"><div class="legend-color color-falling"></div><span>Bloc tombant</span></div>
                    <div class="legend-item"><div class="legend-color color-delayed"></div><span>Pi√®ge retard√©</span></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==================== CONFIGURATION ====================
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        const TILE_SIZE = 50;
        const GRAVITY = 600;
        const FRICTION = 0.85;
        const MAX_FALL_SPEED = 400;

        let currentGame = null;

        // ==================== CLASSE PLAYER ====================
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 30;
                this.height = 40;
                this.velocityX = 0;
                this.velocityY = 0;
                this.isGrounded = false;
                this.moveSpeed = 250;
                this.jumpForce = 350;
                this.alive = true;
                this.spawnX = x;
                this.spawnY = y;
                this.jumpsAvailable = 2;
                this.lastJumpTime = 0;
                this.jumpCooldown = 0.2;
                this.animationFrame = 0;
                this.animationSpeed = 0.1;
                this.direction = 1;
                this.isMoving = false;
                this.deathAnimation = 0;
            }

            update(deltaTime, platforms, traps, fallingBlocks, delayedTraps) {
                this.velocityY += GRAVITY * deltaTime;
                if (this.velocityY > MAX_FALL_SPEED) this.velocityY = MAX_FALL_SPEED;
                this.velocityX *= FRICTION;
                this.x += this.velocityX * deltaTime;
                this.y += this.velocityY * deltaTime;
                this.isGrounded = false;

                for (let platform of platforms) this.checkCollision(platform);
                for (let trap of traps) if (this.checkCollision(trap)) this.alive = false;
                for (let block of fallingBlocks) if (this.checkCollision(block)) this.alive = false;
                for (let trap of delayedTraps) if (trap.active && this.checkCollision(trap)) this.alive = false;
                if (this.y > CANVAS_HEIGHT) this.alive = false;

                if (this.level && this.level.goal) {
                    const goal = this.level.goal;
                    if (this.x + this.width > goal.x && this.x < goal.x + goal.width &&
                        this.y + this.height > goal.y && this.y < goal.y + goal.height) {
                        return 'won';
                    }
                }
                return this.alive ? 'alive' : 'dead';
            }

            checkCollision(rect) {
                if (this.x < rect.x + rect.width && this.x + this.width > rect.x &&
                    this.y < rect.y + rect.height && this.y + this.height > rect.y) {
                    const overlapLeft = (this.x + this.width) - rect.x;
                    const overlapRight = (rect.x + rect.width) - this.x;
                    const overlapTop = (this.y + this.height) - rect.y;
                    const overlapBottom = (rect.y + rect.height) - this.y;
                    const minOverlapX = Math.min(overlapLeft, overlapRight);
                    const minOverlapY = Math.min(overlapTop, overlapBottom);

                    if (minOverlapX < minOverlapY) {
                        if (overlapLeft < overlapRight) this.x = rect.x - this.width;
                        else this.x = rect.x + rect.width;
                        this.velocityX = 0;
                    } else {
                        if (overlapTop < overlapBottom) {
                            this.y = rect.y - this.height;
                            this.velocityY = 0;
                            this.isGrounded = true;
                            this.jumpsAvailable = 2;
                        } else {
                            this.y = rect.y + rect.height;
                            this.velocityY = 0;
                        }
                    }
                    return true;
                }
                return false;
            }

            moveLeft() { this.velocityX = -this.moveSpeed; this.direction = -1; this.isMoving = true; }
            moveRight() { this.velocityX = this.moveSpeed; this.direction = 1; this.isMoving = true; }
            stopMoving() { this.isMoving = false; }
            jump() {
                const currentTime = Date.now() / 1000;
                if (currentTime - this.lastJumpTime < this.jumpCooldown) return;
                if (this.jumpsAvailable > 0) {
                    this.velocityY = -this.jumpForce;
                    this.jumpsAvailable--;
                    this.lastJumpTime = currentTime;
                    this.isGrounded = false;
                }
            }

            reset() {
                this.x = this.spawnX;
                this.y = this.spawnY;
                this.velocityX = 0;
                this.velocityY = 0;
                this.isGrounded = false;
                this.alive = true;
                this.jumpsAvailable = 2;
                this.deathAnimation = 0;
            }

            draw(ctx) {
                if (!this.alive) {
                    this.deathAnimation += 0.05;
                    const scale = Math.max(0, 1 - this.deathAnimation);
                    const rotation = this.deathAnimation * Math.PI;
                    ctx.save();
                    ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                    ctx.rotate(rotation);
                    ctx.globalAlpha = scale;
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    ctx.restore();
                    return;
                }
                if (this.isMoving) {
                    this.animationFrame += this.animationSpeed;
                    if (this.animationFrame > 2) this.animationFrame = 0;
                } else this.animationFrame = 0;

                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y);
                if (this.direction === -1) ctx.scale(-1, 1);
                ctx.translate(-(this.width / 2), 0);
                const bounceOffset = this.isMoving ? Math.sin(this.animationFrame * Math.PI) * 2 : 0;
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(0, bounceOffset, this.width, this.height);
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(5, 8 + bounceOffset, 6, 6);
                ctx.fillRect(19, 8 + bounceOffset, 6, 6);
                ctx.fillStyle = '#000000';
                const pupilOffset = this.isMoving ? 1 : 0;
                ctx.fillRect(6 + pupilOffset, 9 + bounceOffset, 4, 4);
                ctx.fillRect(20 + pupilOffset, 9 + bounceOffset, 4, 4);
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(this.width / 2, 25 + bounceOffset, 3, 0, Math.PI);
                ctx.stroke();
                ctx.restore();

                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.jumpsAvailable, this.x + this.width / 2, this.y - 5);

                if (!this.isGrounded && this.velocityY < 0) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                    ctx.fillRect(this.x, this.y + this.height, this.width, 5);
                }
            }
        }

        // ==================== CLASSE FALLING BLOCK ====================
        class FallingBlock {
            constructor(x, y, width = 50, height = 50) {
                this.x = x; this.y = y; this.width = width; this.height = height;
                this.velocityY = 5; this.falling = false; this.triggerX = x - 100;
                this.triggerWidth = 200; this.rotation = 1;
            }
            update(deltaTime, playerX) {
                if (playerX > this.triggerX && playerX < this.triggerX + this.triggerWidth && !this.falling) this.falling = true;
                if (this.falling) {
                    this.velocityY += GRAVITY * deltaTime;
                    this.y += this.velocityY * deltaTime;
                    this.rotation += 0.1;
                    if (this.y > CANVAS_HEIGHT) {
                        this.y = -this.height; this.velocityY = 0; this.falling = false; this.rotation = 0;
                    }
                }
            }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x + this.width / 2, this.y + this.height / 2); ctx.rotate(this.rotation);
                ctx.fillStyle = '#FFD700'; ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.strokeStyle = '#FFA500'; ctx.lineWidth = 2; ctx.strokeRect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.restore();
            }
        }

        // ==================== CLASSE DELAYED TRAP ====================
        class DelayedTrap {
            constructor(x, y, width = 30, height = 30, delay = 2) {
                this.x = x; this.y = y; this.width = width; this.height = height;
                this.delay = delay; this.timer = 0; this.active = false; this.blinking = false; this.pulse = 0;
            }
            update(deltaTime) {
                this.timer += deltaTime; this.pulse += deltaTime;
                if (this.timer >= this.delay) {
                    this.active = true;
                    this.blinking = Math.floor((this.timer - this.delay) * 4) % 2 === 0;
                }
            }
            draw(ctx) {
                if (this.active && !this.blinking) return;
                ctx.fillStyle = '#FF69B4'; ctx.fillRect(this.x, this.y, this.width, this.height);
                if (!this.active) {
                    const pulseScale = 1 + Math.sin(this.pulse * 3) * 0.1;
                    ctx.fillStyle = 'rgba(255, 105, 180, 0.3)'; ctx.fillRect(this.x - 5, this.y - 15, this.width + 10, 12);
                    ctx.fillStyle = '#FF69B4'; ctx.font = 'bold 10px Arial'; ctx.textAlign = 'center';
                    ctx.fillText(Math.max(0, (this.delay - this.timer).toFixed(1)), this.x + this.width / 2, this.y - 5);
                }
            }
        }

        // ==================== CLASSE LEVEL ====================
        const PLATFORM_WIDTH_MIN = 80; const PLATFORM_WIDTH_MAX = 150; const PLATFORM_HEIGHT = 30;
        const GAP_MIN = 50; const GAP_MAX = 150; const HEIGHT_CHANGE_MAX = 80;
        const MAX_PLATFORMS = 10; const TRAP_CHANCE = 0.4; const FALLING_BLOCK_CHANCE = 0.2; const DELAYED_TRAP_CHANCE = 0.1;

        class Level {
            constructor(levelNumber) {
                this.levelNumber = levelNumber; this.platforms = []; this.traps = [];
                this.fallingBlocks = []; this.delayedTraps = []; this.goal = null;
                this.createLevel();
            }
            createLevel() { this.createRandomLevel(); }
            randomRange(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
            createRandomLevel() {
                this.platforms = []; this.traps = []; this.fallingBlocks = []; this.delayedTraps = [];
                let currentX = 3; let currentY = CANVAS_HEIGHT - 150;
                const startPlatform = { x: 30, y: CANVAS_HEIGHT - 50, width: 100, height: PLATFORM_HEIGHT };
                this.platforms.push(startPlatform);
                currentX = startPlatform.x + startPlatform.width; currentY = startPlatform.y;

	                for (let i = 0; i < MAX_PLATFORMS; i++) {
	                    const gap = this.randomRange(GAP_MIN, GAP_MAX); let nextX = currentX + gap;
	                    const width = this.randomRange(PLATFORM_WIDTH_MIN, PLATFORM_WIDTH_MAX);
	                    const minY = Math.max(100, currentY - HEIGHT_CHANGE_MAX);
	                    const maxY = Math.min(CANVAS_HEIGHT - 50, currentY + HEIGHT_CHANGE_MAX);
	                    let nextY = this.randomRange(minY, maxY);
	                    if (nextY > CANVAS_HEIGHT - 100) nextY = CANVAS_HEIGHT - 100;
	                    const newPlatform = { x: nextX, y: nextY, width: width, height: PLATFORM_HEIGHT };
	                    this.platforms.push(newPlatform);
	                    if (i > 0) this.placeTrapsOnPlatform(this.platforms[i - 1]);
	                    this.placeTrapsBetweenPlatforms(this.platforms[i - 1], newPlatform);
	                    currentX = nextX + width; currentY = nextY;
	                }
	                
	                // CORRECTION: S'assurer que la plateforme finale est dans les limites du canvas
	                let finalX = Math.min(currentX + 50, CANVAS_WIDTH - 100);
	                let finalY = currentY - 50;
	                if (finalY < 100) finalY = 100; // S'assurer qu'elle n'est pas trop haute
	
	                const finalPlatform = { x: finalX, y: finalY, width: 100, height: PLATFORM_HEIGHT };
	                this.platforms.push(finalPlatform);
	                this.placeTrapsOnPlatform(finalPlatform);
	                
	                // CORRECTION: Drapeau d'arriv√©e - Positionn√© sur la plateforme finale
	                this.goal = { 
	                    x: finalPlatform.x + finalPlatform.width - 60, 
	                    y: finalPlatform.y - 90, 
	                    width: 60, 
	                    height: 90 
	                };
	            }
            placeTrapsOnPlatform(platform) {
                if (Math.random() < TRAP_CHANCE) {
                    const trapWidth = 30; const trapHeight = 30;
                    const trapX = platform.x + (platform.width / 2) - (trapWidth / 2);
                    const trapY = platform.y - trapHeight;
                    this.traps.push({ x: trapX, y: trapY, width: trapWidth, height: trapHeight });
                }
                if (Math.random() < DELAYED_TRAP_CHANCE) {
                    const trapWidth = 30; const trapHeight = 30;
                    const trapX = platform.x + this.randomRange(0, platform.width - trapWidth);
                    const trapY = platform.y - trapHeight;
                    const delay = this.randomRange(2, 10);
                    this.delayedTraps.push(new DelayedTrap(trapX, trapY, trapWidth, trapHeight, delay));
                }
            }
            placeTrapsBetweenPlatforms(platform1, platform2) {
                if (Math.random() < FALLING_BLOCK_CHANCE) {
                    const startX = platform1.x + platform1.width; const endX = platform2.x;
                    const midX = startX + (endX - startX) / 2;
                    const blockX = midX - 25; const blockY = platform1.y - 100;
                    this.fallingBlocks.push(new FallingBlock(blockX, blockY));
                }
            }
            update(deltaTime, playerX) {
                for (let block of this.fallingBlocks) block.update(deltaTime, playerX);
                for (let trap of this.delayedTraps) trap.update(deltaTime);
            }
            draw(ctx) {
                ctx.fillStyle = '#8B4513';
                for (let platform of this.platforms) {
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)'; ctx.shadowBlur = 5;
                    ctx.strokeStyle = '#654321'; ctx.lineWidth = 2; ctx.strokeRect(platform.x, platform.y, platform.width, platform.height);
                }
                ctx.fillStyle = '#FF0000';
                for (let trap of this.traps) {
                    ctx.beginPath(); ctx.moveTo(trap.x + trap.width / 2, trap.y);
                    ctx.lineTo(trap.x + trap.width, trap.y + trap.height); ctx.lineTo(trap.x, trap.y + trap.height);
                    ctx.closePath(); ctx.fill(); ctx.strokeStyle = '#CC0000'; ctx.lineWidth = 1; ctx.stroke();
                }
                for (let block of this.fallingBlocks) block.draw(ctx);
                for (let trap of this.delayedTraps) trap.draw(ctx);
                ctx.fillStyle = '#00FF00'; ctx.fillRect(this.goal.x, this.goal.y, this.goal.width, this.goal.height);
                ctx.fillStyle = '#00AA00'; ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center';
                ctx.fillText('FIN', this.goal.x + this.goal.width / 2, this.goal.y + this.goal.height / 2);
            }
        }

        // ==================== GAME ENGINE ====================
        class Game {
            constructor(canvasId, levelNumber) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.player = new Player(10, CANVAS_HEIGHT - 150);
                this.level = new Level(levelNumber);
                this.player.level = this.level;
                this.deaths = 0;
                this.paused = false;
                this.won = false;
                this.lastFrameTime = 0;
                this.keys = {};
                this.audio = { jump: document.getElementById('jumpSound'), fail: document.getElementById('failSound'), win: document.getElementById('winSound') };
                this.setupEventListeners();
            }

            playSound(type) { if (this.audio[type]) { const sound = this.audio[type].cloneNode(); sound.play().catch(e => console.error(e)); } }

            setupEventListeners() {
                window.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    if (e.key === ' ' || e.key.toLowerCase() === 'w' || e.key.toLowerCase() === 'z' || e.key === 'ArrowUp') {
                        this.player.jump(); this.playSound('jump'); e.preventDefault();
                    }
                    if (e.key.toLowerCase() === 'p') this.paused = !this.paused;
                    if (e.key.toLowerCase() === 'r') this.reset();
                });
                window.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                    if (['arrowleft', 'arrowright', 'a', 'd', 'q'].includes(e.key.toLowerCase())) this.player.stopMoving();
                });
                document.getElementById('pauseBtn').addEventListener('click', () => { this.paused = !this.paused; this.updateUI(); });
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());
                document.getElementById('menuBtn').addEventListener('click', () => this.goToMenu());
            }

            handleInput() {
                let isMoving = false;
                if (this.keys['arrowleft'] || this.keys['a'] || this.keys['q']) { this.player.moveLeft(); isMoving = true; }
                if (this.keys['arrowright'] || this.keys['d']) { this.player.moveRight(); isMoving = true; }
                if (!isMoving) this.player.stopMoving();
            }

            update(deltaTime) {
                if (this.paused || !this.player.alive || this.won) return;

                this.handleInput();
                this.level.update(deltaTime, this.player.x);
                const status = this.player.update(deltaTime, this.level.platforms, this.level.traps, this.level.fallingBlocks, this.level.delayedTraps);

                if (status === 'dead') {
                    this.deaths++;
                    this.playSound('fail');
                    // MODIFICATION ICI: On utilise this.reset() pour reg√©n√©rer le niveau
                    setTimeout(() => this.reset(), 500); 
                } else if (status === 'won') {
                    this.won = true;
                    this.playSound('win');
                }
            }

            draw() {
                this.ctx.fillStyle = '#87CEEB'; this.ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                this.level.draw(this.ctx);
                this.player.draw(this.ctx);
                this.ctx.fillStyle = '#000000'; this.ctx.font = 'bold 16px Arial'; this.ctx.textAlign = 'left';
                this.ctx.fillText(`Morts: ${this.deaths}`, 10, 25);
                this.ctx.fillText(`Pos: ${Math.round(this.player.x)}, ${Math.round(this.player.y)}`, 10, 45);

                if (this.paused) {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; this.ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                    this.ctx.fillStyle = '#FFFFFF'; this.ctx.font = 'bold 40px Arial'; this.ctx.textAlign = 'center';
                    this.ctx.fillText('PAUSE', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
                }
                if (this.won) {
                    this.ctx.fillStyle = 'rgba(0, 255, 0, 0.3)'; this.ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                    this.ctx.fillStyle = '#00FF00'; this.ctx.font = 'bold 40px Arial'; this.ctx.textAlign = 'center';
                    this.ctx.fillText('VICTOIRE!', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
                }
                if (!this.player.alive) {
                    this.ctx.fillStyle = 'rgba(255, 0, 0, 0.2)'; this.ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                }
                this.updateUI();
            }

            updateUI() {
                document.getElementById('deathCount').textContent = this.deaths;
                document.getElementById('posX').textContent = Math.round(this.player.x);
                document.getElementById('posY').textContent = Math.round(this.player.y);
                document.getElementById('pauseBtn').textContent = this.paused ? '‚ñ∂Ô∏è Reprendre' : '‚è∏Ô∏è Pause';
                const statusEl = document.getElementById('status');
                if (this.won) { statusEl.textContent = '‚úÖ Victoire!'; statusEl.style.color = '#00FF00'; }
                else if (!this.player.alive) { statusEl.textContent = 'üíÄ Mort'; statusEl.style.color = '#FF0000'; }
                else if (this.paused) { statusEl.textContent = '‚è∏Ô∏è Pause'; statusEl.style.color = '#FFD700'; }
                else { statusEl.textContent = '‚ñ∂Ô∏è En jeu'; statusEl.style.color = '#00FF00'; }
            }

            reset() {
                this.player.reset();
                this.level = new Level(this.level.levelNumber);
                this.player.level = this.level;
                this.paused = false;
                this.won = false;
            }

            goToMenu() {
                document.getElementById('gameScreen').classList.add('hidden');
                document.getElementById('menuScreen').classList.remove('hidden');
                this.stop();
            }

            gameLoop(currentTime) {
                const deltaTime = Math.min((currentTime - this.lastFrameTime) / 1000, 0.016);
                this.lastFrameTime = currentTime;
                this.update(deltaTime);
                this.draw();
                if (currentGame) requestAnimationFrame((time) => this.gameLoop(time));
            }

            start() { requestAnimationFrame((time) => this.gameLoop(time)); }
            stop() { currentGame = null; }
        }

        function startGame(levelNumber) {
            document.getElementById('menuScreen').classList.add('hidden');
            document.getElementById('gameScreen').classList.remove('hidden');
            document.getElementById('levelTitle').textContent = `Niveau ${levelNumber} - Survivez aux Pi√®ges!`;
            currentGame = new Game('gameCanvas', levelNumber);
            currentGame.start();
        }

        window.addEventListener('load', () => {
            document.getElementById('menuScreen').classList.remove('hidden');
            document.getElementById('gameScreen').classList.add('hidden');
        });
    </script>
</body>
</html>
